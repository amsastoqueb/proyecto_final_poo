<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Recorrido Virtual - Tercera Persona (orientación corregida)</title>
  <!-- Cesium 1.115 -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    .leyenda {
      position: absolute;
      bottom: 10px; left: 10px;
      background: rgba(255,255,255,.9);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 0.9em;
      z-index: 10;
      max-width: 380px;
      line-height: 1.35;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div class="leyenda">
    <strong>Controles</strong>
    <ul style="margin:6px 0 0 18px;padding:0;">
      <li>Haz clic en el mapa: el muñeco <em>mira</em> el destino y <em>camina</em> hacia allá.</li>
      <li>La cámara va detrás del muñeco (vista en tercera persona).</li>
      <li>El muñeco atraviesa edificios (sin colisiones) para evitar parpadeos.</li>
    </ul>
  </div>

  <script>
    // ================== Configuración ==================
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4NTIyNDlhYy03OGZhLTRkNTctYjhhOC01NGFlYTRmZGFhNTQiLCJpZCI6MzMxMzcwLCJpYXQiOjE3NTUwNDI1OTF9.01glnnDUpehAFVaOO5v6Vfk5XnvjyEPt6wgYd7jP_9c';

    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: undefined,
      shouldAnimate: true,
      infoBox: false,
      selectionIndicator: false
    });

    viewer.scene.skyBox.show = false;
    viewer.scene.skyAtmosphere.show = false;
    viewer.scene.backgroundColor = Cesium.Color.BLACK;

    // ================== Parámetros del avatar y cámara =================
    const AVATAR_HEIGHT = 1.7;   // m
    const SPEED = 10;           // velocidad (m/s) usada en cálculo por frame
    const STEP_SIZE = 0.6;       // usado en versiones anteriores (no crítico ahora)
    const TICK_MS = 35;
    const STOP_THRESHOLD = 0.5;

    const CAM_BACK = 7.5;
    const CAM_UP = 3.0;
    const CAM_PITCH_DEG = -15;

    // ======= Ajuste para la orientación del modelo =======
    // Si el modelo está "de lado", cambia este valor.
    // -Math.PI/2 = -90°; prueba +Math.PI/2 si el sentido es inverso.
    const MODEL_ROTATION = -Math.PI / 2;

    // ================== Estado ==================
    let personaje = null;
    let modelReady = false;
    let footprintsReady = false;

    let currentPosition = Cesium.Cartesian3.fromDegrees(-74.16566125684365, 4.566368155732512, AVATAR_HEIGHT);
    // Heading del movimiento (mundo), en radianes (dirección donde "avanza" en mapa)
    let currentHeading = 0.0;
    let destination = null;
    let moving = false;

    // ================== Utilidades ==================
    function cartesianToCartographicDeg(cart) {
      const c = Cesium.Ellipsoid.WGS84.cartesianToCartographic(cart);
      return { lon: Cesium.Math.toDegrees(c.longitude), lat: Cesium.Math.toDegrees(c.latitude), height: c.height };
    }

    function setHeight(cartesian, h) {
      const c = Cesium.Ellipsoid.WGS84.cartesianToCartographic(cartesian);
      return Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, h);
    }

    function normalizeVec(v) { return Cesium.Cartesian3.normalize(v, new Cesium.Cartesian3()); }
    function magnitude(v) { return Cesium.Cartesian3.magnitude(v); }

    // computeHeading: heading (radianes) en marco ENU de 'from' hacia 'to'
    function computeHeading(fromCartesian, toCartesian) {
      const enu = Cesium.Transforms.eastNorthUpToFixedFrame(fromCartesian);
      const invEnu = Cesium.Matrix4.inverse(enu, new Cesium.Matrix4());
      const localTo = Cesium.Matrix4.multiplyByPoint(invEnu, toCartesian, new Cesium.Cartesian3());
      return Math.atan2(localTo.x, localTo.y);
    }

    // setModelPose: aplica pose teniendo en cuenta MODEL_ROTATION
    function setModelPose(position, headingRad) {
      if (!personaje) return;
      const adjustedHeading = headingRad + MODEL_ROTATION;
      const hpr = new Cesium.HeadingPitchRoll(adjustedHeading, 0, 0);
      personaje.modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position, hpr);
    }

    // Cámara TPS detrás del avatar (usa heading real del movimiento)
    function updateThirdPersonCamera(pos, headingRad) {
      const hpr = new Cesium.HeadingPitchRoll(headingRad, 0, 0);
      const modelFrame = Cesium.Transforms.headingPitchRollToFixedFrame(pos, hpr);
      const offsetLocal = new Cesium.Cartesian3(0.0, -CAM_BACK, CAM_UP);
      const cameraPos = Cesium.Matrix4.multiplyByPoint(modelFrame, offsetLocal, new Cesium.Cartesian3());

      viewer.camera.setView({
        destination: cameraPos,
        orientation: {
          heading: headingRad,
          pitch: Cesium.Math.toRadians(CAM_PITCH_DEG),
          roll: 0.0
        }
      });
    }

    // ================== Cargar modelo ==================
    Cesium.Model.fromGltfAsync({
      url: './CesiumMan.glb',
      // inicializamos con el ajuste MODEL_ROTATION aplicado
      modelMatrix: Cesium.Transforms.headingPitchRollToFixedFrame(
        currentPosition, new Cesium.HeadingPitchRoll(currentHeading + MODEL_ROTATION, 0, 0)
      ),
      scale: 1,
      minimumPixelSize: 48,
      maximumScale: 2000
    }).then(model => {
      personaje = model;
      viewer.scene.primitives.add(model);
      modelReady = true;

      // asegurar pose visible al inicio (aplica MODEL_ROTATION)
      setModelPose(currentPosition, currentHeading);
      updateThirdPersonCamera(currentPosition, currentHeading);
    }).catch(err => {
      console.error('Error cargando modelo:', err);
    });

    // ================== GeoJSON visual (opcional) ==================
    Cesium.GeoJsonDataSource.load('./arbalta_construcciones_4326.geojson', {
      stroke: Cesium.Color.WHITE,
      fill: Cesium.Color.fromRandom({ alpha: 0.9 }),
      clampToGround: false
    }).then(dataSource => {
      viewer.dataSources.add(dataSource);
      const entities = dataSource.entities.values;
      for (let i = 0; i < entities.length; i++) {
        const e = entities[i];
        if (Cesium.defined(e.polygon) && e.properties && e.properties.CONNPISOS) {
          const pisos = parseInt(e.properties.CONNPISOS.getValue() || 1);
          e.polygon.extrudedHeight = pisos * 3;
          e.polygon.material = Cesium.Color.fromRandom({ alpha: 0.9 });
        }
      }
      footprintsReady = true;
    }).catch(() => { /* geojson opcional */ });

    // ================== Click para establecer destino ==================
    viewer.screenSpaceEventHandler.setInputAction(function(click) {
      if (!personaje) return;

      // pickPosition (requiere servidor o terreno) - fallback a globe.pick
      let picked = viewer.scene.pickPosition(click.position);
      if (!Cesium.defined(picked)) {
        const ray = viewer.camera.getPickRay(click.position);
        picked = viewer.scene.globe.pick(ray, viewer.scene);
      }
      if (!Cesium.defined(picked)) return;

      const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(picked);
      destination = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, AVATAR_HEIGHT);

      // compute heading hacia destino (mundo)
      currentHeading = computeHeading(currentPosition, destination);

      // forzar que el modelo mire primero al destino (aplica MODEL_ROTATION internamente)
      setModelPose(currentPosition, currentHeading);
      updateThirdPersonCamera(currentPosition, currentHeading);

      // empezar movimiento
      moving = true;

      // si model tiene animaciones, activar caminata
      if (personaje && personaje.activeAnimations) {
        try {
          personaje.activeAnimations.removeAll();
          personaje.activeAnimations.addAll({ loop: Cesium.ModelAnimationLoop.REPEAT, speedup: 1.0 });
        } catch (e) {}
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // ================== Movimiento por frame (suave) ==================
    viewer.clock.onTick.addEventListener((clock) => {
      if (!moving || !destination) return;
      const delta = clock.deltaSeconds || 0.016;
      const step = SPEED * delta;

      const toTarget = Cesium.Cartesian3.subtract(destination, currentPosition, new Cesium.Cartesian3());
      const dist = magnitude(toTarget);

      if (dist <= STOP_THRESHOLD) {
        // llegó
        currentPosition = destination;
        moving = false;
        destination = null;

        // detener animaciones
        if (personaje && personaje.activeAnimations) {
          try { personaje.activeAnimations.removeAll(); } catch (e) {}
        }

        // asegurar pose final
        setModelPose(currentPosition, currentHeading);
        updateThirdPersonCamera(currentPosition, currentHeading);
        return;
      }

      // avanzar (sin colisión)
      const moveDir = normalizeVec(toTarget);
      const deltaMove = Cesium.Cartesian3.multiplyByScalar(moveDir, step, new Cesium.Cartesian3());
      currentPosition = Cesium.Cartesian3.add(currentPosition, deltaMove, new Cesium.Cartesian3());

      // recalcular heading del movimiento y aplicar pose (model rotation aplicado internamente)
      currentHeading = computeHeading(currentPosition, Cesium.Cartesian3.add(currentPosition, moveDir, new Cesium.Cartesian3()));
      setModelPose(currentPosition, currentHeading);

      // actualizar cámara TPS
      updateThirdPersonCamera(currentPosition, currentHeading);
    });

    // ================== Vista inicial ==================
    viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(-74.16566125684365, 4.566368155732512, 60),
      orientation: { heading: 0, pitch: Cesium.Math.toRadians(-30), roll: 0 },
      duration: 1.0
    });

    // Espacio para parar movimiento
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        moving = false;
        destination = null;
        if (personaje && personaje.activeAnimations) {
          try { personaje.activeAnimations.removeAll(); } catch (err) {}
        }
      }
    });
  </script>
</body>
</html>
