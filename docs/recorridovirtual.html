<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Recorrido Virtual - Movimiento Suave</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    #cesiumContainer {
      width: 100%;
      height: 100vh;
      margin: 0;
      padding: 0;
    }

    .leyenda {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.85);
      padding: 10px;
      border-radius: 5px;
      font-size: 0.9em;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div class="leyenda">
    <p>Haz clic en el mapa para que el muñeco camine hacia el punto elegido. La cámara lo seguirá. Los edificios están extruidos según el número de pisos.</p>
  </div>

  <script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4NTIyNDlhYy03OGZhLTRkNTctYjhhOC01NGFlYTRmZGFhNTQiLCJpZCI6MzMxMzcwLCJpYXQiOjE3NTUwNDI1OTF9.01glnnDUpehAFVaOO5v6Vfk5XnvjyEPt6wgYd7jP_9c';

    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: undefined,
      shouldAnimate: true
    });

    viewer.scene.skyBox.show = false;
    viewer.scene.skyAtmosphere.show = false;
    viewer.scene.backgroundColor = Cesium.Color.BLACK;
    viewer.extend(Cesium.viewerCesiumInspectorMixin);

    let personaje;
    let currentPosition = Cesium.Cartesian3.fromDegrees(-74.16566125684365, 4.566368155732512, 1);
    let movingInterval = null;

    Cesium.Model.fromGltfAsync({
      url: './CesiumMan.glb',
      modelMatrix: Cesium.Transforms.eastNorthUpToFixedFrame(currentPosition),
      scale: 1,
      minimumPixelSize: 64,
      maximumScale: 2000
    }).then(function (model) {
      personaje = model;
      viewer.scene.primitives.add(model);
      moverCamara(currentPosition);
    });

    Cesium.GeoJsonDataSource.load('./arbalta_construcciones_4326.geojson', {
      stroke: Cesium.Color.WHITE,
      fill: Cesium.Color.fromRandom({ alpha: 1 }),
      clampToGround: false
    }).then(dataSource => {
      viewer.dataSources.add(dataSource);
      const entities = dataSource.entities.values;
      for (let i = 0; i < entities.length; i++) {
        const entity = entities[i];
        if (Cesium.defined(entity.polygon) && entity.properties && entity.properties.CONNPISOS) {
          const pisos = parseInt(entity.properties.CONNPISOS.getValue() || 1);
          entity.polygon.extrudedHeight = pisos * 3;
          entity.polygon.material = Cesium.Color.fromRandom({ alpha: 1 });
          entity.name = "Construcción";
          entity.description = "Pisos: ${pisos}<br>Altura estimada: ${pisos * 3} metros";
        }
      }
    });

    viewer.screenSpaceEventHandler.setInputAction(function (click) {
      const destino = viewer.scene.pickPosition(click.position);
      if (!Cesium.defined(destino) || !personaje) return;
      iniciarMovimiento(destino);
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function iniciarMovimiento(destino) {
      if (movingInterval) clearInterval(movingInterval);

      const direction = Cesium.Cartesian3.subtract(destino, currentPosition, new Cesium.Cartesian3());
      const distance = Cesium.Cartesian3.magnitude(direction);
      Cesium.Cartesian3.normalize(direction, direction);

      const heading = Math.atan2(direction.x, direction.y);
      const hpr = new Cesium.HeadingPitchRoll(heading, 0, 0);

      const anim = personaje.activeAnimations;
      anim.removeAll();
      anim.addAll({
        loop: Cesium.ModelAnimationLoop.REPEAT,
        speedup: 1.0
      });

      let steps = Math.floor(distance / 0.5);
      let stepCount = 0;
      const stepSize = 0.5;

      movingInterval = setInterval(() => {
        if (stepCount >= steps) {
          clearInterval(movingInterval);
          anim.removeAll();
          currentPosition = destino;
          personaje.modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(destino, hpr);
          return;
        }

        const nextPosition = Cesium.Cartesian3.add(
          currentPosition,
          Cesium.Cartesian3.multiplyByScalar(direction, stepSize, new Cesium.Cartesian3()),
          new Cesium.Cartesian3()
        );

        currentPosition = nextPosition;
        personaje.modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(currentPosition, hpr);
        moverCamara(currentPosition);
        stepCount++;
      }, 50);
    }

    function moverCamara(pos) {
      const localMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(pos);
      const offset = new Cesium.Cartesian3(0.0, -6.0, 1.7);
      const cameraPos = Cesium.Matrix4.multiplyByPoint(localMatrix, offset, new Cesium.Cartesian3());

      viewer.camera.setView({
        destination: cameraPos,
        orientation: {
          heading: 0,
          pitch: Cesium.Math.toRadians(-10),
          roll: 0.0
        }
      });
    }
  </script>
</body>
</html>